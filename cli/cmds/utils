#!/usr/bin/env bash

trap "echo 'Exiting...'; exit 1" SIGINT

BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

check_input() {
    local input_value="$1"
    local input_name="$2"
    if [[ -z "$input_value" ]]; then
        echo "No input received for $input_name. Exiting..."
        exit 1
    fi
}

format_address() {
    local address=$1
    local prefix=${address:0:6}
    local suffix=${address: -4}
    echo "${prefix}...${suffix}"
}

set_rpc_url() {
    case $1 in
        1) RPC_URL="https://cloudflare-eth.com" ;; # Ethereum
        137) RPC_URL="https://polygon-rpc.com" ;; # Polygon
        8453) RPC_URL="https://mainnet.base.org" ;; # Base
        42161) RPC_URL="https://arb1.arbitrum.io/rpc" ;; # Arbitrum
        1329) RPC_URL="https://evm-rpc.sei-apis.com" ;; # Sei
        33139) RPC_URL="https://rpc.apechain.com/http" ;; # ApeChain
        11155111) RPC_URL="https://ethereum-sepolia-rpc.publicnode.com" ;; # Sepolia
        *) echo "Unsupported chain id"; exit 1 ;;
    esac

    export RPC_URL
}

process_stages() {
    local stages_file="$1"
    local output_file="$2"
    local token_standard="$3"

    npx ts-node "$BASE_DIR/../../scripts/utils/getStagesData.ts" "$stages_file" "$output_file" "$token_standard"

    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to get stages data"
        return 1
    fi

    if [[ ! -f "$output_file" ]]; then
        echo "Error: Output file not found: $output_file"
        return 1
    fi
}

get_contract_address_from_logs() {
    local deployment_data="$1"
    local event_sig="$2"
    
    for log in $(echo "$deployment_data" | jq -c '.logs[]'); do
        local topic0=$(echo "$log" | jq -r '.topics[0]')
        if [ "$topic0" == "$event_sig" ]; then
            echo $(echo "$log" | jq -r '.data' | sed 's/^0x//')
            return
        fi
    done
}

decode_address() {
  chunk=$1
  # Take the last 40 characters (20 bytes for an address)
  echo "0x${chunk:24}"
}

save_deployment_data() {
    chain_id=$1
    contract_address=$2
    name=$3
    symbol=$4
    token_standard=$5
    initial_owner=$6
    impl_id=$7

    # Get the current timestamp
    timestamp=$(date +%s)
    # Create the directory if it doesn't exist
    deployment_dir="./deployments/$chain_id"
    mkdir -p "$deployment_dir"

    # Create a JSON object with the provided data
    json_data=$(jq -n \
        --arg chain_id "$chain_id" \
        --arg contract_address "$contract_address" \
        --arg name "$name" \
        --arg symbol "$symbol" \
        --arg token_standard "$token_standard" \
        --arg initial_owner "$initial_owner" \
        --arg impl_id "$impl_id" \
        --arg timestamp "$timestamp" \
        '{
            chain_id: $chain_id,
            contract_address: $contract_address,
            name: $name,
            symbol: $symbol,
            token_standard: $token_standard,
            initial_owner: $initial_owner,
            impl_id: $impl_id,
            timestamp: $timestamp
        }')

    file_name="$name-$token_standard-$timestamp.json"
    echo "$json_data" > "$deployment_dir/$file_name"
    echo "Deployment details saved to $deployment_dir/$file_name"
}

prestart() {
    # Fetch the latest changes from the remote
    git -C "$BASE_DIR" fetch

    # Check if the local main is behind the remote main
    LOCAL=$(git -C "$BASE_DIR" rev-parse @)
    REMOTE=$(git -C "$BASE_DIR" rev-parse @{u})
    BASE=$(git -C "$BASE_DIR" merge-base @ @{u})

    if [ $LOCAL = $REMOTE ]; then
        echo "You are up-to-date with the main branch."
    elif [ $LOCAL = $BASE ]; then
        echo "Your local main branch is behind the remote. Please pull the latest changes."
        exit 1
    elif [ $REMOTE = $BASE ]; then
        echo "Your local main branch is ahead of the remote."
    else
        echo "Your local main branch has diverged from the remote."
        exit 1
    fi

    forge build --root "$BASE_DIR"
}

load_deployment_data() {
    local deployment_file="$1"
    if [[ ! -f "$deployment_file" ]]; then
        echo "Error: Deployment file not found: $deployment_file"
        return 1
    fi


    jq -r '
        .chain_id,
        .contract_address,
        .name,
        .symbol,
        .token_standard,
        .initial_owner,
        .impl_id
    ' "$deployment_file"
}

check_signer_native_balance() {
    local chain_id="$1"
    set_rpc_url $chain_id
    local balance=$(cast balance $SIGNER --rpc-url "$RPC_URL")
    local from_wei=$(cast from-wei $balance)
    printf "%.3f\n" $from_wei
}

chain_id_to_symbol() {
    local chain_id="$1"
    case $chain_id in
        1) echo "ETH" ;;
        137) echo "MATIC" ;;
        8453) echo "BASE" ;;
        42161) echo "ARB" ;;
        1329) echo "SEI" ;;
        33139) echo "APE" ;;
        11155111) echo "SEP" ;;
        *) echo "Unknown" ;;
    esac
}

chain_id_to_explorer_url() {
    local chain_id="$1"
    case $chain_id in
        1) echo "https://etherscan.io" ;;
        137) echo "https://polygonscan.com" ;;
        8453) echo "https://explorer.base.org" ;;
        42161) echo "https://arbiscan.io" ;;
        1329) echo "https://sei.explorer.sepolia.io" ;;
        33139) echo "https://explorer.caldera.xyz" ;;
        11155111) echo "https://sepolia.etherscan.io" ;;
        *) echo "Unknown" ;;
    esac
}

format_explorer_contract_url() {
    local chain_id="$1"
    local contract_address="$2"
    local explorer_url=$(chain_id_to_explorer_url $chain_id)
    echo "$explorer_url/address/$contract_address"
}

format_explorer_tx_url() {
    local chain_id="$1"
    local tx_hash="$2"
    local explorer_url=$(chain_id_to_explorer_url $chain_id)
    echo "$explorer_url/tx/$tx_hash"
}

get_standard_id() {
    case $1 in
        "ERC721") echo "0" ;;
        "ERC1155") echo "1" ;;
        *) echo "Unknown" ;;
    esac
}